<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <link rel="stylesheet" href="/assets/css/style.css">

</head>
<body>
    <main>
        <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clarion for GIS Consultants - Clarion Context Engine</title>
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/icp-pages.css">
</head>
<body>
    <!-- Header Navigation -->
    <header class="main-header">
        <div class="header-container">
            <div class="header-logo">
                <a href="/" class="logo-text">Clarion</a>
            </div>
            <nav class="header-nav">
                <a href="/" class="nav-link">Home</a>
                <a href="/#features" class="nav-link">Features</a>
                <a href="/#about" class="nav-link">About</a>
                <a href="/#contact" class="nav-link">Contact</a>
                <a href="/#demo" class="nav-link demo-link">Demo</a>
            </nav>
            <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </header>

    <!-- ICP Page Hero Section -->
    <section class="icp-hero">
        <div class="icp-hero-background">
            <div class="icp-grid-overlay"></div>
            <div class="icp-floating-particles"></div>
        </div>
        
        <div class="icp-hero-content">
            <div class="icp-header">
                <div class="icp-icon">üó∫Ô∏è</div>
                <h1 class="icp-title">Clarion for GIS Consultants</h1>
                <p class="icp-subtitle">ArcGIS is your foundation. Clarion makes it intelligent.</p>
            </div>
        </div>
    </section>

    <!-- Main Content -->
    <main class="icp-main">
        <div class="icp-container">
            <article class="icp-content">
                <h2 id="acknowledge-whats-out-there">Acknowledge What‚Äôs Out There</h2>

<p>Many utilities already use ArcGIS-based systems to track assets, issue work orders, and maintain spatial databases.</p>

<p><strong>Tools like:</strong></p>
<ul>
  <li><strong>Cityworks / Elements XS</strong> for CMMS-style maintenance tracking</li>
  <li><strong>Cartegraph</strong> for infrastructure inventory and inspections</li>
  <li><strong>Field Maps &amp; Survey123</strong> for collecting field data</li>
</ul>

<p>These are powerful ‚Äî and they‚Äôre built on a platform you know.</p>

<h2 id="but-heres-what-clarion-does-differently">But Here‚Äôs What Clarion Does Differently</h2>

<p>Where traditional GIS-based platforms manage data, <strong>Clarion manages context.</strong></p>

<p>Clarion deeply indexes all the information around your GIS assets ‚Äî so staff can search, ask questions, and act with clarity.</p>

<h2 id="key-differentiators-for-gis-consultants">Key Differentiators for GIS Consultants</h2>

<h3 id="-contextual-search--semantic-links">‚úÖ Contextual Search + Semantic Links</h3>
<ul>
  <li><strong>Link maintenance logs, SOPs, manuals, meeting notes, and engineering reports directly to GIS assets</strong></li>
  <li><strong>Full-text searchable, but also semantically structured:</strong> Clarion understands asset relationships, history, and topology</li>
</ul>

<div class="highlight-box">
üí¨ **Ask: "When was this pump last rebuilt?" ‚Äî and get an answer, not just a folder.**
</div>

<h3 id="-natural-language-assistant-for-non-gis-staff">‚úÖ Natural Language Assistant for Non-GIS Staff</h3>
<ul>
  <li><strong>Operators and admin staff don‚Äôt need to navigate ArcGIS or know layer names</strong></li>
  <li><strong>Clarion‚Äôs AI assistant lets anyone ask about assets, locations, tasks, or history ‚Äî in plain English</strong></li>
</ul>

<div class="highlight-box">
üß† **"Which valves need flushing this month?" ‚Üí Clarion answers, from GIS + logs**
</div>

<h3 id="-cross-platform-intelligence">‚úÖ Cross-Platform Intelligence</h3>
<ul>
  <li><strong>GIS is just one source ‚Äî Clarion integrates with AMI (e.g. Sensus), SCADA, hydraulic models, and docs</strong></li>
  <li><strong>The knowledge graph keeps it all in sync, using asset IDs and topology as the connective tissue</strong></li>
</ul>

<div class="highlight-box">
üß© **Your GIS becomes the heart of a smart utility ecosystem.**
</div>

<h2 id="why-gis-consultants-bring-in-clarion">Why GIS Consultants Bring in Clarion</h2>

<ul>
  <li><strong>Keeps your ArcGIS work actively used across teams</strong></li>
  <li><strong>Bridges your deliverables to daily operations</strong></li>
  <li><strong>Positions you to offer long-term services:</strong> onboarding, QA, data linking</li>
</ul>

<div class="quote-box">
<p>With Clarion, I didn't just deliver a map. I delivered a system they use every day.</p>
<div class="attribution">‚Äî GIS Consultant, Water Resources</div>
</div>

<h2 id="professional-benefits">Professional Benefits</h2>

<h3 id="-clarion-extends-their-work-beyond-the-gis-department">‚úÖ Clarion Extends Their Work Beyond the GIS Department</h3>
<p>Most GIS consultants deliver incredible spatial data ‚Äî but that data often gets siloed.</p>

<div class="highlight-box">
üîÅ **With Clarion:**
- That GIS work now powers knowledge management, training, operations, and engineering decisions
- The consultant's role expands from "map builder" to systems integrator and digital transformation partner
</div>

<h3 id="-clarion-creates-sticky-ongoing-engagement">‚úÖ Clarion Creates Sticky, Ongoing Engagement</h3>
<p>Clarion isn‚Äôt a one-and-done tool. It opens up:</p>
<ul>
  <li><strong>Future integrations</strong> (AMI, SCADA, hydraulic modeling)</li>
  <li><strong>Asset knowledge curation and SOP linking</strong></li>
  <li><strong>Staff training and onboarding support</strong></li>
</ul>

<p>This enables ongoing consulting opportunities:</p>
<ul>
  <li>Data linking</li>
  <li>Quality assurance</li>
  <li>Custom dashboards and automation</li>
  <li>Acting as their ‚ÄúGIS + Clarion advisor‚Äù</li>
</ul>

<div class="highlight-box">
üí° **More revenue. Longer contracts. A seat at the digital strategy table.**
</div>

<h3 id="-professional-differentiation">‚úÖ Professional Differentiation</h3>
<p>Most consultants are still handing off PDFs and static maps. Clarion lets the GIS consultant say:</p>

<p><strong>‚ÄúWe don‚Äôt just map assets ‚Äî we make them intelligent.‚Äù</strong></p>

<p>This positions the consultant as an innovator ‚Äî someone bringing new value to aging infrastructure and resource-constrained utilities.</p>

<div class="cta-section">
<h2>Clarion makes your GIS work indispensable</h2>
<p>Transform your GIS deliverables into intelligent, interactive systems that drive daily operations.</p>
<div class="cta-buttons">
<a href="/#demo" class="cta-button">Watch a Use Case</a>
<a href="/#features" class="cta-button secondary">Become a Certified Partner</a>
</div>
</div>

            </article>
        </div>
    </main>

    <!-- Footer -->
    <footer class="icp-footer">
        <div class="container">
            <p>&copy; 2025 Clarion Context Engine. All rights reserved.</p>
        </div>
    </footer>

    <script>
        // Mobile menu toggle
        function toggleMobileMenu() {
            const nav = document.querySelector('.header-nav');
            const toggle = document.querySelector('.mobile-menu-toggle');
            nav.classList.toggle('active');
            toggle.classList.toggle('active');
        }
    </script>
</body>
</html> 
    </main>
    <footer>
        <div class="container">
            <p>&copy; 2025 . All rights reserved.</p>
        </div>
    </footer>
    <script>
        // Focused Knowledge Graph with Clear Theme Transitions
        class FocusedKnowledgeGraph {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.container = null;
                this.nodes = new Map();
                this.particles = [];
                this.currentTheme = 0;
                this.animationId = null;
                this.isTransitioning = false;
                
                // Three focused themes with clear, distinct animations
                this.themes = [
                    {
                        name: 'Asset Management',
                        text: 'Asset Management',
                        description: 'Complete lifecycle tracking and optimization',
                        primaryColor: 'rgba(66, 165, 245, 0.8)',
                        secondaryColor: 'rgba(30, 136, 229, 0.6)',
                        flows: [
                            { from: 'gis', to: 'assets', intensity: 'high', delay: 0 },
                            { from: 'scada', to: 'assets', intensity: 'high', delay: 200 },
                            { from: 'assets', to: 'projects', intensity: 'medium', delay: 400 },
                            { from: 'schedule', to: 'projects', intensity: 'medium', delay: 600 },
                            { from: 'assets', to: 'compliance', intensity: 'low', delay: 800 }
                        ],
                        highlightNodes: ['gis', 'scada', 'assets', 'projects', 'schedule', 'compliance']
                    },
                    {
                        name: 'Hydraulic Modeling',
                        text: 'Hydraulic Modeling', 
                        description: 'Real-time simulation and predictive analytics',
                        primaryColor: 'rgba(105, 240, 174, 0.8)',
                        secondaryColor: 'rgba(0, 200, 83, 0.6)',
                        flows: [
                            { from: 'scada', to: 'modeling', intensity: 'high', delay: 0 },
                            { from: 'ami', to: 'modeling', intensity: 'high', delay: 150 },
                            { from: 'gis', to: 'modeling', intensity: 'medium', delay: 300 },
                            { from: 'modeling', to: 'projects', intensity: 'medium', delay: 500 },
                            { from: 'modeling', to: 'alerts', intensity: 'medium', delay: 650 },
                            { from: 'modeling', to: 'compliance', intensity: 'low', delay: 800 }
                        ],
                        highlightNodes: ['scada', 'ami', 'gis', 'modeling', 'projects', 'alerts']
                    },
                    {
                        name: 'Knowledge Management',
                        text: 'Knowledge Management',
                        description: 'AI-powered insights and decision support', 
                        primaryColor: 'rgba(255, 193, 7, 0.8)',
                        secondaryColor: 'rgba(255, 152, 0, 0.6)',
                        flows: [
                            { from: 'docs', to: 'knowledge', intensity: 'high', delay: 0 },
                            { from: 'cusi', to: 'knowledge', intensity: 'medium', delay: 200 },
                            { from: 'assets', to: 'knowledge', intensity: 'medium', delay: 350 },
                            { from: 'modeling', to: 'knowledge', intensity: 'medium', delay: 500 },
                            { from: 'knowledge', to: 'alerts', intensity: 'high', delay: 700 },
                            { from: 'knowledge', to: 'compliance', intensity: 'medium', delay: 900 }
                        ],
                        highlightNodes: ['docs', 'cusi', 'assets', 'modeling', 'knowledge', 'alerts', 'compliance']
                    }
                ];
                
                this.init();
            }
            
            init() {
                document.addEventListener('DOMContentLoaded', () => {
                    this.setupCanvas();
                    this.initializeNodes();
                    this.setupThemeRotation();
                    this.startAnimation();
                });
            }
            
            setupCanvas() {
                this.canvas = document.getElementById('particleCanvas');
                this.container = document.querySelector('.knowledge-graph');
                if (!this.canvas || !this.container) {
                    console.log('Knowledge graph elements not found - skipping initialization');
                    return;
                }
                
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    console.log('Could not get canvas context - skipping initialization');
                    return;
                }
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                if (!this.container || !this.canvas) return; // Safety check
                
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            initializeNodes() {
                setTimeout(() => {
                    const dataNodes = [
                        'gis', 'docs', 'scada', 'cusi', 'ami', 'schedule',
                        'knowledge', 'assets', 'projects', 'alerts', 'modeling', 'compliance'
                    ];
                    const angles = [0, 60, 120, 180, 240, 300, 30, 90, 150, 210, 270, 330];
                    dataNodes.forEach((nodeId, index) => {
                        const angle = angles[index];
                        const element = document.querySelector(`[data-type="${nodeId}"]`);
                        if (element) {
                            element.style.setProperty('--angle', angle);
                            element.style.animationDelay = `${angle * 0.01}s`;
                            this.nodes.set(nodeId, { element, angle, type: 'data' });
                        }
                    });
                    const coreElement = document.querySelector('.intelligence-core');
                    if (coreElement) {
                        this.nodes.set('core', { element: coreElement, angle: 0, type: 'core' });
                    }
                    // Start with first theme
                    this.activateTheme(0);
                }, 100);
            }
            
            setupThemeRotation() {
                // Slower rotation for better appreciation
                setInterval(() => {
                    if (!this.isTransitioning) {
                        this.nextTheme();
                    }
                }, 6000); // 6 seconds per theme
            }
            
            nextTheme() {
                this.currentTheme = (this.currentTheme + 1) % this.themes.length;
                this.activateTheme(this.currentTheme);
            }
            
            activateTheme(themeIndex) {
                if (this.isTransitioning) return;
                if (!this.container) return; // Safety check
                
                this.isTransitioning = true;
                this.currentTheme = themeIndex;
                const theme = this.themes[themeIndex];
                
                // Set theme data attribute for CSS theming
                this.container.setAttribute('data-theme', themeIndex);
                
                // Dramatic transition sequence
                this.startThemeTransition(theme);
            }
            
            startThemeTransition(theme) {
                // Smooth, non-jarring transition
                this.clearParticles();
                this.updateThemeText(theme);
                this.updateNodeEmphasis(theme);
                this.activateParticleFlows(theme);
            }
            
            clearParticles() {
                // Gradually fade out existing particles
                this.particles.forEach(particle => {
                    particle.life *= 0.3;
                });
            }
            
            updateThemeText(theme) {
                const textElement = document.querySelector('.rotating-text');
                if (textElement) {
                    textElement.style.transition = 'all 0.4s ease';
                    textElement.style.opacity = '0.7';
                    
                    setTimeout(() => {
                        textElement.textContent = theme.text;
                        textElement.style.opacity = '1';
                        textElement.style.color = theme.primaryColor;
                        textElement.style.textShadow = `0 0 20px ${theme.primaryColor}`;
                    }, 200);
                }
            }
            
            updateNodeEmphasis(theme) {
                // Reset all nodes to baseline state
                this.nodes.forEach(node => {
                    if (node.element) {
                        node.element.classList.remove('kg-primary', 'kg-secondary', 'kg-inactive');
                        node.element.style.filter = '';
                    }
                });
                
                // Apply subtle emphasis without changing layout
                const primaryNodes = theme.highlightNodes.slice(0, 3);
                const secondaryNodes = theme.highlightNodes.slice(3);
                
                // Highlight primary nodes (key to this theme)
                primaryNodes.forEach(nodeId => {
                    const node = this.nodes.get(nodeId);
                    if (node?.element) {
                        node.element.classList.add('kg-primary');
                        node.element.style.filter = `drop-shadow(0 0 12px ${theme.primaryColor})`;
                    }
                });
                
                // Subtle highlight for secondary nodes
                secondaryNodes.forEach(nodeId => {
                    const node = this.nodes.get(nodeId);
                    if (node?.element) {
                        node.element.classList.add('kg-secondary');
                        node.element.style.filter = `drop-shadow(0 0 8px ${theme.secondaryColor})`;
                    }
                });
                
                // Slightly de-emphasize unrelated nodes
                this.nodes.forEach((node, nodeId) => {
                    if (!theme.highlightNodes.includes(nodeId) && nodeId !== 'core') {
                        if (node.element) {
                            node.element.classList.add('kg-inactive');
                        }
                    }
                });
            }
            
            activateParticleFlows(theme) {
                // Start particle flows with staggered timing
                theme.flows.forEach(flow => {
                    setTimeout(() => {
                        this.createThemeParticleFlow(flow, theme);
                    }, flow.delay);
                });
                
                // Complete transition smoothly
                setTimeout(() => {
                    this.isTransitioning = false;
                }, 1500);
            }
            
            createThemeParticleFlow(flow, theme) {
                const fromNode = this.nodes.get(flow.from);
                const toNode = this.nodes.get(flow.to);
                
                if (!fromNode || !toNode) return;
                
                const fromPos = this.getNodePosition(fromNode);
                const toPos = this.getNodePosition(toNode);
                
                // Intensity-based particle count and characteristics  
                const particleCount = flow.intensity === 'high' ? 15 : flow.intensity === 'medium' ? 10 : 6;
                const particleSize = flow.intensity === 'high' ? 5 : flow.intensity === 'medium' ? 3.5 : 2.5;
                const color = flow.intensity === 'high' ? theme.primaryColor : theme.secondaryColor;
                
                // Create particles with staggered release
                for (let i = 0; i < particleCount; i++) {
                    setTimeout(() => {
                        this.particles.push(new ThemeParticle(fromPos, toPos, color, particleSize, theme));
                    }, i * 80);
                }
            }
            
            getNodePosition(node) {
                if (!node.element) return { x: 0, y: 0 };
                
                const rect = node.element.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();
                
                return {
                    x: rect.left + rect.width / 2 - canvasRect.left,
                    y: rect.top + rect.height / 2 - canvasRect.top
                };
            }
            
            startAnimation() {
                if (!this.ctx || !this.canvas) return; // Safety check
                
                const animate = () => {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.particles = this.particles.filter(particle => {
                        particle.update();
                        particle.draw(this.ctx);
                        return particle.life > 0;
                    });
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                
                animate();
            }
            
            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        }
        
        // Enhanced particle class for theme-specific effects
        class ThemeParticle {
            constructor(start, end, color, size, theme) {
                this.start = { ...start };
                this.end = { ...end };
                this.position = { ...start };
                this.color = color;
                this.theme = theme;
                this.life = 1.0;
                this.speed = 0.015 + Math.random() * 0.02;
                this.progress = 0;
                this.size = size;
                this.trail = [];
                this.maxTrailLength = 10;
                this.glowIntensity = 0.8;
            }
            
            update() {
                this.progress += this.speed;
                
                const eased = this.easeInOutCubic(this.progress);
                
                this.position.x = this.start.x + (this.end.x - this.start.x) * eased;
                this.position.y = this.start.y + (this.end.y - this.start.y) * eased;
                
                this.trail.push({ ...this.position });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                if (this.progress >= 1) {
                    this.life -= 0.03;
                } else {
                    this.life = Math.min(1, this.progress * 4);
                }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                // Enhanced trail with theme colors
                for (let i = 0; i < this.trail.length; i++) {
                    const trailPoint = this.trail[i];
                    const trailAlpha = (i / this.trail.length) * this.life * 0.4;
                    const trailSize = (i / this.trail.length) * this.size * 0.6;
                    
                    ctx.save();
                    ctx.globalAlpha = trailAlpha;
                    ctx.fillStyle = this.theme.secondaryColor;
                    ctx.beginPath();
                    ctx.arc(trailPoint.x, trailPoint.y, trailSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Main particle with enhanced glow
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15 * this.glowIntensity;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner bright core
                ctx.shadowBlur = 0;
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.8})`;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
        }
        
        // Initialize the focused knowledge graph only if required elements exist
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('particleCanvas');
            const container = document.querySelector('.knowledge-graph');
            
            // Only initialize if both canvas and container exist (not on homepage)
            if (canvas && container) {
                const focusedGraph = new FocusedKnowledgeGraph();
            }
        });
    </script>
</body>
</html> 