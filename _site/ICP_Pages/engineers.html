<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <link rel="stylesheet" href="/assets/css/style.css">

</head>
<body>
    <main>
        <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clarion for Utility Engineers - Clarion Context Engine</title>
    <link rel="stylesheet" href="/assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/icp-pages.css">
</head>
<body>
    <!-- Header Navigation -->
    <header class="main-header">
        <div class="header-container">
            <div class="header-logo">
                <a href="/" class="logo-text">Clarion</a>
            </div>
            <nav class="header-nav">
                <a href="/" class="nav-link">Home</a>
                <a href="/#features" class="nav-link">Features</a>
                <a href="/#about" class="nav-link">About</a>
                <a href="/#contact" class="nav-link">Contact</a>
                <a href="/#demo" class="nav-link demo-link">Demo</a>
            </nav>
            <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </header>

    <!-- ICP Page Hero Section -->
    <section class="icp-hero">
        <div class="icp-hero-background">
            <div class="icp-grid-overlay"></div>
            <div class="icp-floating-particles"></div>
        </div>
        
        <div class="icp-hero-content">
            <div class="icp-header">
                <div class="icp-icon">🔧</div>
                <h1 class="icp-title">Clarion for Utility Engineers</h1>
                <p class="icp-subtitle">Deliver lasting value. Work closer with your clients. Spend less time chasing context.</p>
            </div>
        </div>
    </section>

    <!-- Main Content -->
    <main class="icp-main">
        <div class="icp-container">
            <article class="icp-content">
                <h2 id="problem-we-solve">Problem We Solve</h2>

<p>You build great systems — but then what?</p>

<p>Your clients are buried in PDFs, emails, and scattered knowledge. You wait days for a single asset spec or operational SOP. Your plans go stale before they’re even implemented.</p>

<h2 id="what-clarion-does-for-engineers">What Clarion Does for Engineers</h2>

<h3 id="-living-master-plan">🔁 Living Master Plan</h3>
<p>Tie your hydraulic model, reports, and system recommendations into a dynamic interface your client can use — daily.</p>

<ul>
  <li><strong>Host models directly in Clarion</strong></li>
  <li><strong>Enable “what-if” scenario exploration</strong></li>
  <li><strong>Connect your plan to real-world system status &amp; updates</strong></li>
</ul>

<div class="highlight-box">
🟦 **No more plans that gather dust.** You're giving your clients something they can build on.
</div>

<h3 id="-query-the-clients-system-not-their-inbox">🔍 Query the Client’s System, Not Their Inbox</h3>
<p>Stop waiting on info requests.</p>

<ul>
  <li><strong>Search SOPs, asset history, and project docs via semantic knowledge graph</strong></li>
  <li><strong>Ask Clarion:</strong>
    <ul>
      <li>“Where are the highest nighttime demands?”</li>
      <li>“Has this zone ever had pressure complaints?”</li>
    </ul>
  </li>
</ul>

<div class="highlight-box">
🟦 **Save hours every week.** Get what you need when you need it.
</div>

<h3 id="-tighter-collaboration-without-email-overload">🤝 Tighter Collaboration Without Email Overload</h3>
<p>Get a role-based login as a trusted partner.</p>

<ul>
  <li><strong>Access tagged documents, tasks, and workflows</strong></li>
  <li><strong>Leave notes, receive alerts, and follow changes to the parts of the system you care about</strong></li>
</ul>

<div class="highlight-box">
🟦 **Be the engineer they call first — because you're already in the loop.**
</div>

<h3 id="-bonus-a-differentiator-for-your-proposals">💡 Bonus: A Differentiator for Your Proposals</h3>
<p>Offer Clarion as part of your service.</p>

<p><strong>“We don’t just leave you with a binder. We empower your team to use this plan every day.”</strong></p>

<div class="highlight-box">
🟦 **Clarion makes your firm the long-term partner, not just the consultant.**
</div>

<h2 id="real-results">Real Results</h2>

<div class="quote-box">
<p>Clarion lets me stay connected to the system I helped design.</p>
<div class="attribution">— Senior Engineer, Water Resources</div>
</div>

<div class="cta-section">
<h2>See how Clarion enhances your engineering workflow</h2>
<p>Discover how Clarion can transform your deliverables into living, interactive systems.</p>
<div class="cta-buttons">
<a href="/#demo" class="cta-button">Request Demo</a>
<a href="/#features" class="cta-button secondary">Watch Sample Use Case</a>
</div>
</div>

            </article>
        </div>
    </main>

    <!-- Footer -->
    <footer class="icp-footer">
        <div class="container">
            <p>&copy; 2025 Clarion Context Engine. All rights reserved.</p>
        </div>
    </footer>

    <script>
        // Mobile menu toggle
        function toggleMobileMenu() {
            const nav = document.querySelector('.header-nav');
            const toggle = document.querySelector('.mobile-menu-toggle');
            nav.classList.toggle('active');
            toggle.classList.toggle('active');
        }
    </script>
</body>
</html> 
    </main>
    <footer>
        <div class="container">
            <p>&copy; 2025 . All rights reserved.</p>
        </div>
    </footer>
    <script>
        // Focused Knowledge Graph with Clear Theme Transitions
        class FocusedKnowledgeGraph {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.container = null;
                this.nodes = new Map();
                this.particles = [];
                this.currentTheme = 0;
                this.animationId = null;
                this.isTransitioning = false;
                
                // Three focused themes with clear, distinct animations
                this.themes = [
                    {
                        name: 'Asset Management',
                        text: 'Asset Management',
                        description: 'Complete lifecycle tracking and optimization',
                        primaryColor: 'rgba(66, 165, 245, 0.8)',
                        secondaryColor: 'rgba(30, 136, 229, 0.6)',
                        flows: [
                            { from: 'gis', to: 'assets', intensity: 'high', delay: 0 },
                            { from: 'scada', to: 'assets', intensity: 'high', delay: 200 },
                            { from: 'assets', to: 'projects', intensity: 'medium', delay: 400 },
                            { from: 'schedule', to: 'projects', intensity: 'medium', delay: 600 },
                            { from: 'assets', to: 'compliance', intensity: 'low', delay: 800 }
                        ],
                        highlightNodes: ['gis', 'scada', 'assets', 'projects', 'schedule', 'compliance']
                    },
                    {
                        name: 'Hydraulic Modeling',
                        text: 'Hydraulic Modeling', 
                        description: 'Real-time simulation and predictive analytics',
                        primaryColor: 'rgba(105, 240, 174, 0.8)',
                        secondaryColor: 'rgba(0, 200, 83, 0.6)',
                        flows: [
                            { from: 'scada', to: 'modeling', intensity: 'high', delay: 0 },
                            { from: 'ami', to: 'modeling', intensity: 'high', delay: 150 },
                            { from: 'gis', to: 'modeling', intensity: 'medium', delay: 300 },
                            { from: 'modeling', to: 'projects', intensity: 'medium', delay: 500 },
                            { from: 'modeling', to: 'alerts', intensity: 'medium', delay: 650 },
                            { from: 'modeling', to: 'compliance', intensity: 'low', delay: 800 }
                        ],
                        highlightNodes: ['scada', 'ami', 'gis', 'modeling', 'projects', 'alerts']
                    },
                    {
                        name: 'Knowledge Management',
                        text: 'Knowledge Management',
                        description: 'AI-powered insights and decision support', 
                        primaryColor: 'rgba(255, 193, 7, 0.8)',
                        secondaryColor: 'rgba(255, 152, 0, 0.6)',
                        flows: [
                            { from: 'docs', to: 'knowledge', intensity: 'high', delay: 0 },
                            { from: 'cusi', to: 'knowledge', intensity: 'medium', delay: 200 },
                            { from: 'assets', to: 'knowledge', intensity: 'medium', delay: 350 },
                            { from: 'modeling', to: 'knowledge', intensity: 'medium', delay: 500 },
                            { from: 'knowledge', to: 'alerts', intensity: 'high', delay: 700 },
                            { from: 'knowledge', to: 'compliance', intensity: 'medium', delay: 900 }
                        ],
                        highlightNodes: ['docs', 'cusi', 'assets', 'modeling', 'knowledge', 'alerts', 'compliance']
                    }
                ];
                
                this.init();
            }
            
            init() {
                document.addEventListener('DOMContentLoaded', () => {
                    this.setupCanvas();
                    this.initializeNodes();
                    this.setupThemeRotation();
                    this.startAnimation();
                });
            }
            
            setupCanvas() {
                this.canvas = document.getElementById('particleCanvas');
                this.container = document.querySelector('.knowledge-graph');
                if (!this.canvas || !this.container) {
                    console.log('Knowledge graph elements not found - skipping initialization');
                    return;
                }
                
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    console.log('Could not get canvas context - skipping initialization');
                    return;
                }
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                if (!this.container || !this.canvas) return; // Safety check
                
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            initializeNodes() {
                setTimeout(() => {
                    const dataNodes = [
                        'gis', 'docs', 'scada', 'cusi', 'ami', 'schedule',
                        'knowledge', 'assets', 'projects', 'alerts', 'modeling', 'compliance'
                    ];
                    const angles = [0, 60, 120, 180, 240, 300, 30, 90, 150, 210, 270, 330];
                    dataNodes.forEach((nodeId, index) => {
                        const angle = angles[index];
                        const element = document.querySelector(`[data-type="${nodeId}"]`);
                        if (element) {
                            element.style.setProperty('--angle', angle);
                            element.style.animationDelay = `${angle * 0.01}s`;
                            this.nodes.set(nodeId, { element, angle, type: 'data' });
                        }
                    });
                    const coreElement = document.querySelector('.intelligence-core');
                    if (coreElement) {
                        this.nodes.set('core', { element: coreElement, angle: 0, type: 'core' });
                    }
                    // Start with first theme
                    this.activateTheme(0);
                }, 100);
            }
            
            setupThemeRotation() {
                // Slower rotation for better appreciation
                setInterval(() => {
                    if (!this.isTransitioning) {
                        this.nextTheme();
                    }
                }, 6000); // 6 seconds per theme
            }
            
            nextTheme() {
                this.currentTheme = (this.currentTheme + 1) % this.themes.length;
                this.activateTheme(this.currentTheme);
            }
            
            activateTheme(themeIndex) {
                if (this.isTransitioning) return;
                if (!this.container) return; // Safety check
                
                this.isTransitioning = true;
                this.currentTheme = themeIndex;
                const theme = this.themes[themeIndex];
                
                // Set theme data attribute for CSS theming
                this.container.setAttribute('data-theme', themeIndex);
                
                // Dramatic transition sequence
                this.startThemeTransition(theme);
            }
            
            startThemeTransition(theme) {
                // Smooth, non-jarring transition
                this.clearParticles();
                this.updateThemeText(theme);
                this.updateNodeEmphasis(theme);
                this.activateParticleFlows(theme);
            }
            
            clearParticles() {
                // Gradually fade out existing particles
                this.particles.forEach(particle => {
                    particle.life *= 0.3;
                });
            }
            
            updateThemeText(theme) {
                const textElement = document.querySelector('.rotating-text');
                if (textElement) {
                    textElement.style.transition = 'all 0.4s ease';
                    textElement.style.opacity = '0.7';
                    
                    setTimeout(() => {
                        textElement.textContent = theme.text;
                        textElement.style.opacity = '1';
                        textElement.style.color = theme.primaryColor;
                        textElement.style.textShadow = `0 0 20px ${theme.primaryColor}`;
                    }, 200);
                }
            }
            
            updateNodeEmphasis(theme) {
                // Reset all nodes to baseline state
                this.nodes.forEach(node => {
                    if (node.element) {
                        node.element.classList.remove('kg-primary', 'kg-secondary', 'kg-inactive');
                        node.element.style.filter = '';
                    }
                });
                
                // Apply subtle emphasis without changing layout
                const primaryNodes = theme.highlightNodes.slice(0, 3);
                const secondaryNodes = theme.highlightNodes.slice(3);
                
                // Highlight primary nodes (key to this theme)
                primaryNodes.forEach(nodeId => {
                    const node = this.nodes.get(nodeId);
                    if (node?.element) {
                        node.element.classList.add('kg-primary');
                        node.element.style.filter = `drop-shadow(0 0 12px ${theme.primaryColor})`;
                    }
                });
                
                // Subtle highlight for secondary nodes
                secondaryNodes.forEach(nodeId => {
                    const node = this.nodes.get(nodeId);
                    if (node?.element) {
                        node.element.classList.add('kg-secondary');
                        node.element.style.filter = `drop-shadow(0 0 8px ${theme.secondaryColor})`;
                    }
                });
                
                // Slightly de-emphasize unrelated nodes
                this.nodes.forEach((node, nodeId) => {
                    if (!theme.highlightNodes.includes(nodeId) && nodeId !== 'core') {
                        if (node.element) {
                            node.element.classList.add('kg-inactive');
                        }
                    }
                });
            }
            
            activateParticleFlows(theme) {
                // Start particle flows with staggered timing
                theme.flows.forEach(flow => {
                    setTimeout(() => {
                        this.createThemeParticleFlow(flow, theme);
                    }, flow.delay);
                });
                
                // Complete transition smoothly
                setTimeout(() => {
                    this.isTransitioning = false;
                }, 1500);
            }
            
            createThemeParticleFlow(flow, theme) {
                const fromNode = this.nodes.get(flow.from);
                const toNode = this.nodes.get(flow.to);
                
                if (!fromNode || !toNode) return;
                
                const fromPos = this.getNodePosition(fromNode);
                const toPos = this.getNodePosition(toNode);
                
                // Intensity-based particle count and characteristics  
                const particleCount = flow.intensity === 'high' ? 15 : flow.intensity === 'medium' ? 10 : 6;
                const particleSize = flow.intensity === 'high' ? 5 : flow.intensity === 'medium' ? 3.5 : 2.5;
                const color = flow.intensity === 'high' ? theme.primaryColor : theme.secondaryColor;
                
                // Create particles with staggered release
                for (let i = 0; i < particleCount; i++) {
                    setTimeout(() => {
                        this.particles.push(new ThemeParticle(fromPos, toPos, color, particleSize, theme));
                    }, i * 80);
                }
            }
            
            getNodePosition(node) {
                if (!node.element) return { x: 0, y: 0 };
                
                const rect = node.element.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();
                
                return {
                    x: rect.left + rect.width / 2 - canvasRect.left,
                    y: rect.top + rect.height / 2 - canvasRect.top
                };
            }
            
            startAnimation() {
                if (!this.ctx || !this.canvas) return; // Safety check
                
                const animate = () => {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.particles = this.particles.filter(particle => {
                        particle.update();
                        particle.draw(this.ctx);
                        return particle.life > 0;
                    });
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                
                animate();
            }
            
            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        }
        
        // Enhanced particle class for theme-specific effects
        class ThemeParticle {
            constructor(start, end, color, size, theme) {
                this.start = { ...start };
                this.end = { ...end };
                this.position = { ...start };
                this.color = color;
                this.theme = theme;
                this.life = 1.0;
                this.speed = 0.015 + Math.random() * 0.02;
                this.progress = 0;
                this.size = size;
                this.trail = [];
                this.maxTrailLength = 10;
                this.glowIntensity = 0.8;
            }
            
            update() {
                this.progress += this.speed;
                
                const eased = this.easeInOutCubic(this.progress);
                
                this.position.x = this.start.x + (this.end.x - this.start.x) * eased;
                this.position.y = this.start.y + (this.end.y - this.start.y) * eased;
                
                this.trail.push({ ...this.position });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                if (this.progress >= 1) {
                    this.life -= 0.03;
                } else {
                    this.life = Math.min(1, this.progress * 4);
                }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                // Enhanced trail with theme colors
                for (let i = 0; i < this.trail.length; i++) {
                    const trailPoint = this.trail[i];
                    const trailAlpha = (i / this.trail.length) * this.life * 0.4;
                    const trailSize = (i / this.trail.length) * this.size * 0.6;
                    
                    ctx.save();
                    ctx.globalAlpha = trailAlpha;
                    ctx.fillStyle = this.theme.secondaryColor;
                    ctx.beginPath();
                    ctx.arc(trailPoint.x, trailPoint.y, trailSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Main particle with enhanced glow
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15 * this.glowIntensity;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner bright core
                ctx.shadowBlur = 0;
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.8})`;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
        }
        
        // Initialize the focused knowledge graph only if required elements exist
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('particleCanvas');
            const container = document.querySelector('.knowledge-graph');
            
            // Only initialize if both canvas and container exist (not on homepage)
            if (canvas && container) {
                const focusedGraph = new FocusedKnowledgeGraph();
            }
        });
    </script>
</body>
</html> 