<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <link rel="stylesheet" href="/assets/css/style.css">

</head>
<body>
    <main>
        <article class="page">
  <h2>Product Overview</h2>
  <div class="page-content">
    <div class="container">

# Clarion: Product Overview

**Clarion** is an intelligent infrastructure management platform developed by **Snowball Systems**. It serves as a "digital twin" for complex physical systems, primarily targeting water and wastewater utilities.

The core of Clarion is a powerful knowledge graph that unifies an organization's scattered data sources into a single, queryable model. This includes:

-   **Unstructured Documents:** Technical manuals, operational reports, meeting minutes, proposals (.pdf, .txt, etc.).
-   **Geospatial Data:** Asset locations and network topology from GIS systems.
-   **Operational Models:** Hydraulic simulation models like EPANET.

By integrating these disparate sources, Clarion provides a holistic, real-time view of infrastructure assets and operations. Users can interact with this complex dataset using natural language, asking questions and receiving context-aware answers grounded in their own data. This is powered by an advanced Retrieval-Augmented Generation (RAG) AI agent.

The platform is not just for data exploration; it's an active management tool. It features integrated modules for asset management, project management (with Kanban, Gantt, and list views), and hydraulic network simulation, allowing teams to plan, execute, and monitor their work within the same environment where their data lives.

Clarion is designed to break down data silos, enhance institutional knowledge, and empower operators and managers to make faster, more informed decisions. 

</div>

  </div>
</article> 
    </main>
    <footer>
        <div class="container">
            <p>&copy; 2025 . All rights reserved.</p>
        </div>
    </footer>
    <script>
        // Focused Knowledge Graph with Clear Theme Transitions
        class FocusedKnowledgeGraph {
            constructor() {
                this.canvas = null;
                this.ctx = null;
                this.container = null;
                this.nodes = new Map();
                this.particles = [];
                this.currentTheme = 0;
                this.animationId = null;
                this.isTransitioning = false;
                
                // Three focused themes with clear, distinct animations
                this.themes = [
                    {
                        name: 'Asset Management',
                        text: 'Asset Management',
                        description: 'Complete lifecycle tracking and optimization',
                        primaryColor: 'rgba(66, 165, 245, 0.8)',
                        secondaryColor: 'rgba(30, 136, 229, 0.6)',
                        flows: [
                            { from: 'gis', to: 'assets', intensity: 'high', delay: 0 },
                            { from: 'scada', to: 'assets', intensity: 'high', delay: 200 },
                            { from: 'assets', to: 'projects', intensity: 'medium', delay: 400 },
                            { from: 'schedule', to: 'projects', intensity: 'medium', delay: 600 },
                            { from: 'assets', to: 'compliance', intensity: 'low', delay: 800 }
                        ],
                        highlightNodes: ['gis', 'scada', 'assets', 'projects', 'schedule', 'compliance']
                    },
                    {
                        name: 'Hydraulic Modeling',
                        text: 'Hydraulic Modeling', 
                        description: 'Real-time simulation and predictive analytics',
                        primaryColor: 'rgba(105, 240, 174, 0.8)',
                        secondaryColor: 'rgba(0, 200, 83, 0.6)',
                        flows: [
                            { from: 'scada', to: 'modeling', intensity: 'high', delay: 0 },
                            { from: 'ami', to: 'modeling', intensity: 'high', delay: 150 },
                            { from: 'gis', to: 'modeling', intensity: 'medium', delay: 300 },
                            { from: 'modeling', to: 'projects', intensity: 'medium', delay: 500 },
                            { from: 'modeling', to: 'alerts', intensity: 'medium', delay: 650 },
                            { from: 'modeling', to: 'compliance', intensity: 'low', delay: 800 }
                        ],
                        highlightNodes: ['scada', 'ami', 'gis', 'modeling', 'projects', 'alerts']
                    },
                    {
                        name: 'Knowledge Management',
                        text: 'Knowledge Management',
                        description: 'AI-powered insights and decision support', 
                        primaryColor: 'rgba(255, 193, 7, 0.8)',
                        secondaryColor: 'rgba(255, 152, 0, 0.6)',
                        flows: [
                            { from: 'docs', to: 'knowledge', intensity: 'high', delay: 0 },
                            { from: 'cusi', to: 'knowledge', intensity: 'medium', delay: 200 },
                            { from: 'assets', to: 'knowledge', intensity: 'medium', delay: 350 },
                            { from: 'modeling', to: 'knowledge', intensity: 'medium', delay: 500 },
                            { from: 'knowledge', to: 'alerts', intensity: 'high', delay: 700 },
                            { from: 'knowledge', to: 'compliance', intensity: 'medium', delay: 900 }
                        ],
                        highlightNodes: ['docs', 'cusi', 'assets', 'modeling', 'knowledge', 'alerts', 'compliance']
                    }
                ];
                
                this.init();
            }
            
            init() {
                document.addEventListener('DOMContentLoaded', () => {
                    this.setupCanvas();
                    this.initializeNodes();
                    this.setupThemeRotation();
                    this.startAnimation();
                });
            }
            
            setupCanvas() {
                this.canvas = document.getElementById('particleCanvas');
                this.container = document.querySelector('.knowledge-graph');
                if (!this.canvas || !this.container) return;
                
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            initializeNodes() {
                setTimeout(() => {
                    const dataNodes = [
                        'gis', 'docs', 'scada', 'cusi', 'ami', 'schedule',
                        'knowledge', 'assets', 'projects', 'alerts', 'modeling', 'compliance'
                    ];
                    const angles = [0, 60, 120, 180, 240, 300, 30, 90, 150, 210, 270, 330];
                    dataNodes.forEach((nodeId, index) => {
                        const angle = angles[index];
                        const element = document.querySelector(`[data-type="${nodeId}"]`);
                        if (element) {
                            element.style.setProperty('--angle', angle);
                            element.style.animationDelay = `${angle * 0.01}s`;
                            this.nodes.set(nodeId, { element, angle, type: 'data' });
                        }
                    });
                    const coreElement = document.querySelector('.intelligence-core');
                    if (coreElement) {
                        this.nodes.set('core', { element: coreElement, angle: 0, type: 'core' });
                    }
                    // Start with first theme
                    this.activateTheme(0);
                }, 100);
            }
            
            setupThemeRotation() {
                // Slower rotation for better appreciation
                setInterval(() => {
                    if (!this.isTransitioning) {
                        this.nextTheme();
                    }
                }, 6000); // 6 seconds per theme
            }
            
            nextTheme() {
                this.currentTheme = (this.currentTheme + 1) % this.themes.length;
                this.activateTheme(this.currentTheme);
            }
            
            activateTheme(themeIndex) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                this.currentTheme = themeIndex;
                const theme = this.themes[themeIndex];
                
                // Set theme data attribute for CSS theming
                this.container.setAttribute('data-theme', themeIndex);
                
                // Dramatic transition sequence
                this.startThemeTransition(theme);
            }
            
            startThemeTransition(theme) {
                // Smooth, non-jarring transition
                this.clearParticles();
                this.updateThemeText(theme);
                this.updateNodeEmphasis(theme);
                this.activateParticleFlows(theme);
            }
            
            clearParticles() {
                // Gradually fade out existing particles
                this.particles.forEach(particle => {
                    particle.life *= 0.3;
                });
            }
            
            updateThemeText(theme) {
                const textElement = document.querySelector('.rotating-text');
                if (textElement) {
                    textElement.style.transition = 'all 0.4s ease';
                    textElement.style.opacity = '0.7';
                    
                    setTimeout(() => {
                        textElement.textContent = theme.text;
                        textElement.style.opacity = '1';
                        textElement.style.color = theme.primaryColor;
                        textElement.style.textShadow = `0 0 20px ${theme.primaryColor}`;
                    }, 200);
                }
            }
            
            updateNodeEmphasis(theme) {
                // Reset all nodes to baseline state
                this.nodes.forEach(node => {
                    if (node.element) {
                        node.element.classList.remove('kg-primary', 'kg-secondary', 'kg-inactive');
                        node.element.style.filter = '';
                    }
                });
                
                // Apply subtle emphasis without changing layout
                const primaryNodes = theme.highlightNodes.slice(0, 3);
                const secondaryNodes = theme.highlightNodes.slice(3);
                
                // Highlight primary nodes (key to this theme)
                primaryNodes.forEach(nodeId => {
                    const node = this.nodes.get(nodeId);
                    if (node?.element) {
                        node.element.classList.add('kg-primary');
                        node.element.style.filter = `drop-shadow(0 0 12px ${theme.primaryColor})`;
                    }
                });
                
                // Subtle highlight for secondary nodes
                secondaryNodes.forEach(nodeId => {
                    const node = this.nodes.get(nodeId);
                    if (node?.element) {
                        node.element.classList.add('kg-secondary');
                        node.element.style.filter = `drop-shadow(0 0 8px ${theme.secondaryColor})`;
                    }
                });
                
                // Slightly de-emphasize unrelated nodes
                this.nodes.forEach((node, nodeId) => {
                    if (!theme.highlightNodes.includes(nodeId) && nodeId !== 'core') {
                        if (node.element) {
                            node.element.classList.add('kg-inactive');
                        }
                    }
                });
            }
            
            activateParticleFlows(theme) {
                // Start particle flows with staggered timing
                theme.flows.forEach(flow => {
                    setTimeout(() => {
                        this.createThemeParticleFlow(flow, theme);
                    }, flow.delay);
                });
                
                // Complete transition smoothly
                setTimeout(() => {
                    this.isTransitioning = false;
                }, 1500);
            }
            
            createThemeParticleFlow(flow, theme) {
                const fromNode = this.nodes.get(flow.from);
                const toNode = this.nodes.get(flow.to);
                
                if (!fromNode || !toNode) return;
                
                const fromPos = this.getNodePosition(fromNode);
                const toPos = this.getNodePosition(toNode);
                
                // Intensity-based particle count and characteristics  
                const particleCount = flow.intensity === 'high' ? 15 : flow.intensity === 'medium' ? 10 : 6;
                const particleSize = flow.intensity === 'high' ? 5 : flow.intensity === 'medium' ? 3.5 : 2.5;
                const color = flow.intensity === 'high' ? theme.primaryColor : theme.secondaryColor;
                
                // Create particles with staggered release
                for (let i = 0; i < particleCount; i++) {
                    setTimeout(() => {
                        this.particles.push(new ThemeParticle(fromPos, toPos, color, particleSize, theme));
                    }, i * 80);
                }
            }
            
            getNodePosition(node) {
                if (!node.element) return { x: 0, y: 0 };
                
                const rect = node.element.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();
                
                return {
                    x: rect.left + rect.width / 2 - canvasRect.left,
                    y: rect.top + rect.height / 2 - canvasRect.top
                };
            }
            
            startAnimation() {
                const animate = () => {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.particles = this.particles.filter(particle => {
                        particle.update();
                        particle.draw(this.ctx);
                        return particle.life > 0;
                    });
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                
                animate();
            }
            
            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
        }
        
        // Enhanced particle class for theme-specific effects
        class ThemeParticle {
            constructor(start, end, color, size, theme) {
                this.start = { ...start };
                this.end = { ...end };
                this.position = { ...start };
                this.color = color;
                this.theme = theme;
                this.life = 1.0;
                this.speed = 0.015 + Math.random() * 0.02;
                this.progress = 0;
                this.size = size;
                this.trail = [];
                this.maxTrailLength = 10;
                this.glowIntensity = 0.8;
            }
            
            update() {
                this.progress += this.speed;
                
                const eased = this.easeInOutCubic(this.progress);
                
                this.position.x = this.start.x + (this.end.x - this.start.x) * eased;
                this.position.y = this.start.y + (this.end.y - this.start.y) * eased;
                
                this.trail.push({ ...this.position });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                if (this.progress >= 1) {
                    this.life -= 0.03;
                } else {
                    this.life = Math.min(1, this.progress * 4);
                }
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                // Enhanced trail with theme colors
                for (let i = 0; i < this.trail.length; i++) {
                    const trailPoint = this.trail[i];
                    const trailAlpha = (i / this.trail.length) * this.life * 0.4;
                    const trailSize = (i / this.trail.length) * this.size * 0.6;
                    
                    ctx.save();
                    ctx.globalAlpha = trailAlpha;
                    ctx.fillStyle = this.theme.secondaryColor;
                    ctx.beginPath();
                    ctx.arc(trailPoint.x, trailPoint.y, trailSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Main particle with enhanced glow
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15 * this.glowIntensity;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner bright core
                ctx.shadowBlur = 0;
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.8})`;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
        }
        
        // Initialize the focused knowledge graph
        const focusedGraph = new FocusedKnowledgeGraph();
    </script>
</body>
</html> 